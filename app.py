# -*- coding: utf-8 -*-
"""app_antaka.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F3s-Lx0Hzz8MItJoJc3uhvZkGF52e8FE

#LIBRARY
"""

from transformers import BertTokenizerFast, BertForTokenClassification
from openai import OpenAI
import requests
import random
import torch
import json
import re



"""#DATA"""

# URL file JSON
url_category = "https://raw.githubusercontent.com/claraisrasyamdah/antaka_2025/refs/heads/main/support_data/category_mapping.json"

try:
    response_category = requests.get(url_category)
    response_category.raise_for_status()  # untuk memunculkan error kalau gagal

    category_mapping = json.loads(response_category.text)

except requests.exceptions.RequestException as e:
    print(f"Terjadi kesalahan saat mengunduh data: {e}")

# URL file JSON
url_city = "https://raw.githubusercontent.com/claraisrasyamdah/antaka_2025/refs/heads/main/support_data/city_mapping.json"

try:
    response_city = requests.get(url_city)
    response_city.raise_for_status()  # untuk memunculkan error kalau gagal

    city_mapping = json.loads(response_city.text)

except requests.exceptions.RequestException as e:
    print(f"Terjadi kesalahan saat mengunduh data: {e}")

# URL file JSON
url_mapping_place = "https://raw.githubusercontent.com/claraisrasyamdah/antaka_2025/refs/heads/main/support_data/mapping_place_alias.json"

try:
    response_mapping_place = requests.get(url_mapping_place)
    response_mapping_place.raise_for_status()  # untuk memunculkan error kalau gagal

    mapping_place_alias = json.loads(response_mapping_place.text)

except requests.exceptions.RequestException as e:
    print(f"Terjadi kesalahan saat mengunduh data: {e}")

# Unduh data dari URL
url = "https://raw.githubusercontent.com/claraisrasyamdah/antaka_2025/refs/heads/main/data/data_wisata.json"
response = requests.get(url)
data_wisata_raw = json.loads(response.text)

# Buat versi yang huruf kecil semua di City dan Category
data_wisata = []
for place in data_wisata_raw:
    place["City"] = place["City"].lower()
    place["Category"] = place["Category"].lower()
    place["Place_Name"] = place["Place_Name"].lower()
    data_wisata.append(place)

data_wisata_raw = json.loads(response.text)

"""#CALLING MODEL"""

# Load model & tokenizer dari Hugging Face Hub
model_name = "claraisra/antaka-v2"
tokenizer = BertTokenizerFast.from_pretrained(model_name)
model = BertForTokenClassification.from_pretrained(model_name)
model.eval()

"""#FUNCTION

##FUNC SUPPORT
"""

def predict_bio(text):
    tokens = tokenizer(text, return_tensors="pt", truncation=True, is_split_into_words=False)
    word_ids = tokens.word_ids(batch_index=0)  # <-- mapping ke kata asli
    with torch.no_grad():
        output = model(**tokens)

    logits = output.logits
    predictions = torch.argmax(logits, dim=2)[0]

    predicted_labels = [model.config.id2label[p.item()] for p in predictions]

    token_words = tokenizer.convert_ids_to_tokens(tokens['input_ids'][0])

    # Gabungkan token dan label berdasar kata asli
    results = []
    previous_word_idx = None
    for token, label, word_idx in zip(token_words, predicted_labels, word_ids):
        if word_idx is None or token in tokenizer.all_special_tokens:
            continue
        if word_idx != previous_word_idx:
            results.append((token, label))  # token baru
        else:
            if label.startswith("I-"):
                results[-1] = (results[-1][0] + token.replace("##", ""), label)
            # else: abaikan label O tambahan
        previous_word_idx = word_idx

    return results

# Fungsi prompting untuk ekstraksi key_highlights, tanggal, dan bahasa
def get_place_name(user_input):
    messages = [
        {
            "role": "system",
            "content": "Anda adalah asisten cerdas yang mengekstraksi nama tempat wisata dari pernyataan pengguna. Kembalikan hanya nama tempat wisata, tanpa penjelasan tambahan."
        },
        {
            "role": "user",
            "content": f"Tolong ekstrak nama tempat dari kalimat ini: \"{user_input}\""
        }
    ]

    response = client.chat.completions.create(
        model=MODEL_NAME,
        messages=messages,
        temperature=0
    )

    content = response.choices[0].message.content.strip()
    return content

def find_specific_place(input_text, mapping_place_alias, data_wisata):
    input_text_lower = input_text.lower()
    place_name_extracted = get_place_name(input_text_lower).lower()

    for canonical_name, alias_list in mapping_place_alias.items():
        for alias in alias_list:
            if alias.lower() == place_name_extracted:

                # Cari tempat yang cocok di data_wisata dengan nama canonical
                matching_places = [
                    place for place in data_wisata
                    if canonical_name.lower() in place["Place_Name"].lower()
                ]

                if matching_places:
                    if len(matching_places) == 1:
                        return matching_places[0]  # Kembalikan seluruh objek
                    else:
                        matching_places_sorted = sorted(matching_places, key=lambda x: x["Rating"], reverse=True)
                        return matching_places_sorted[0]  # Kembalikan yang rating-nya tertinggi

    # Jika tidak ada kecocokan
    return None

# Mapping kata kunci ibadah
KEYWORD_CATEGORY_MAP = {
    "masjid": "Tempat Ibadah",
    "mushola": "Tempat Ibadah",
    "gereja": "Tempat Ibadah",
    "vihara": "Tempat Ibadah",
    "klenteng": "Tempat Ibadah",
    "pura": "Tempat Ibadah",
    "kapel": "Tempat Ibadah",
}

def find_matching_wisata(input_text, entities, mapping_place_alias=mapping_place_alias, data_wisata=data_wisata_raw):
    input_text_lower = input_text.lower()
    matches = []

    # Coba cari tempat spesifik dulu
    specific_place = find_specific_place(input_text, mapping_place_alias, data_wisata)
    if specific_place:
        matches.append(specific_place)
    else:
        # Ambil keyword spesifik tempat ibadah dari input (jika ada)
        keyword_ibadah = None
        if entities["CATEGORY"] == "Tempat Ibadah":
            for keyword in KEYWORD_CATEGORY_MAP:
                if keyword in input_text_lower:
                    keyword_ibadah = keyword
                    break

        for place in data_wisata:
            # Filter berdasarkan kota
            if entities["CITY"] and entities["CITY"].lower() not in place["City"].lower():
                continue
            # Filter berdasarkan kategori
            if entities["CATEGORY"] and entities["CATEGORY"].lower() not in place["Category"].lower():
                continue
            # Filter harga
            if entities["PRICE"] is not None and place["Price"] > entities["PRICE"]:
                continue
            # Filter rating
            if entities["RATING"] is not None and place["Rating"] < entities["RATING"]:
                continue
            # Jika keyword ibadah terdeteksi, pastikan ada di nama tempat
            if keyword_ibadah and keyword_ibadah not in place["Place_Name"].lower():
                continue
            matches.append(place)

    sorted_matches = sorted(matches, key=lambda x: (x["Price"], -x["Rating"]))
    top_matches = random.sample(sorted_matches, k=min(5, len(sorted_matches)))

    return [place["Place_Id"] for place in top_matches]

def extract_entities(token_label_pairs):
    entities = {
        "CATEGORY": None,
        "CITY": None,
        "PRICE": None,
        "RATING": None
    }

    current_entity = None
    for token, label in token_label_pairs:
        if label.startswith("B-"):
            current_entity = label[2:]
            if current_entity in ["CATEGORY", "CITY"]:
                entities[current_entity] = token
            elif current_entity == "PRICE":
                if token.isdigit():
                    entities[current_entity] = int(token)
            elif current_entity == "RATING":
                if token.isdigit():
                    try:
                        entities[current_entity] = float(token)
                    except ValueError:
                        entities[current_entity] = 0.0

        elif label.startswith("I-"):
            entity_type = label[2:]
            if entity_type in ["CATEGORY", "CITY"]:
                if entities[entity_type] is None:
                    # Tangani kasus I-XXX tanpa B-XXX sebelumnya
                    entities[entity_type] = token
                else:
                    entities[entity_type] += " " + token

    return entities

"""##FUNC MAIN"""

# Inisialisasi kredensial API
openai.api_key = os.getenv("OPENAI_API_KEY")
MODEL_NAME = "gpt-3.5-turbo"

# Inisialisasi client OpenAI
client = OpenAI(api_key=openai_api_key)

def normalize_entities(entities):
    def normalize_city(city):
        if not city:
            return None
        city = city.lower().strip()
        return city_mapping.get(city, None)

    def normalize_category(cat):
        if not cat:
            return None
        cat = cat.lower().strip()
        return category_mapping.get(cat, None)

    def normalize_price(price_str):
        if not price_str:
            return None
        price_str = price_str.lower()
        if any(w in price_str for w in ['bebas']):
            return 0
        if any(w in price_str for w in ['murah', 'terjangkau', 'hemat']):
            return 10000
        if any(w in price_str for w in ['sedang', 'standar']):
            return 25000
        if any(w in price_str for w in ['mahal', 'mewah']):
            return 100000

        price_str = price_str.replace("rb", "000").replace("ribu", "000").replace("k", "000")
        digits = re.findall(r'\d+', price_str)

        if digits:
            number = int(''.join(digits))
            if number < 1000:
                number *= 1000
            return number

        return None

    def normalize_rating(rating_str):
        if not rating_str:
            return None
        rating_str = rating_str.lower()
        if rating_str in ['buruk', 'sangat buruk', 'mengecewakan']:
            return 1.0
        if rating_str in ['kurang bagus', 'biasa aja', 'lumayan']:
            return 2.5
        if rating_str in ['cukup bagus', 'oke']:
            return 3.5
        if rating_str in ['bagus', 'recommended', 'bebas']:
            return 4.0
        if rating_str in ['sangat bagus', 'luar biasa', 'mantap']:
            return 4.5
        if rating_str in ['sempurna', 'sangat memuaskan']:
            return 5.0

        try:
            return float(rating_str)
        except:
            return None

    return {
        "CITY": normalize_city(entities.get("CITY")),
        "CATEGORY": normalize_category(entities.get("CATEGORY")),
        "PRICE": normalize_price(str(entities.get("PRICE"))),
        "RATING": normalize_rating(str(entities.get("RATING"))),
    }

"""#API"""

import gradio as gr
import requests

# Fungsi generate pertanyaan
def generate_pertanyaan(confirmed_state):
    pertanyaan = []
    for entitas in confirmed_state:
        if not confirmed_state[entitas]:
            if entitas == "CATEGORY":
                pertanyaan.append("Jenis wisata apa yang kamu mau? (Misal: Religi, Taman, Budaya...)")
            elif entitas == "CITY":
                pertanyaan.append("Kota tujuannya di mana? (Misal: Yogyakarta, Bandung...)")
            elif entitas == "PRICE":
                pertanyaan.append("Maksimal harga tiketnya berapa? (Contoh: 50000, 50rb)")
            elif entitas == "RATING":
                pertanyaan.append("Minimal rating tempatnya? (Contoh: 4, 3.0, 3)")
    return pertanyaan

def semua_terkonfirmasi(state):
    return all(state.values())

# Placeholder: ganti ini dengan fungsi aslimu
def predict_bio(text): return [text]
def extract_entities(prediction): return {}
def normalize_entities(entities): return {}
def find_matching_wisata(user_input, state): return []
data_wisata_raw = []  # Ganti ini dengan datamu

google_api_key = "AIzaSyBaA8PrK-2TxY-fUhQNxWjA8Z_FizeRLYc"

# Fungsi utama untuk dipanggil Gradio
def chatbot_interface(user_input, start_lat=-6.9733, start_lng=107.6303, start_name="Start Point",
                      user_session_state=None, confirmed_state=None):

    if user_session_state is None:
        user_session_state = {"CATEGORY": None, "CITY": None, "PRICE": None, "RATING": None}
    if confirmed_state is None:
        confirmed_state = {"CATEGORY": False, "CITY": False, "PRICE": False, "RATING": False}

    prediction = predict_bio(user_input)
    prediction.append(user_input)
    entities = normalize_entities(extract_entities(prediction[:-1]))

    bebas_keywords = ["tidak tahu", "skip", "ga tau", "gak tau", "bebas", "terserah", "apa aja", "semua", "kategori apapun", "harga berapapun", "gak ada minimal rating", "ga ada batasan"]

    if any(k in user_input.lower() for k in bebas_keywords):
        for key in confirmed_state:
            if not confirmed_state[key]:
                confirmed_state[key] = True
    elif "harga berapapun" in user_input.lower():
        confirmed_state["PRICE"] = True
    else:
        for key in user_session_state:
            if key in entities and entities[key] is not None:
                user_session_state[key] = entities[key]
                confirmed_state[key] = True

    if semua_terkonfirmasi(confirmed_state):
        hasil = find_matching_wisata(user_input, user_session_state)
        if hasil:
            list_tempat = [d for d in data_wisata_raw if d["Place_Id"] in hasil]

            rute = [{"Place_Name": start_name, "Lat": start_lat, "Long": start_lng}] + list_tempat

            estimasi_total_jarak_km = 0
            estimasi_total_waktu_menit = 0

            for i in range(len(rute) - 1):
                origin = f"{rute[i]['Lat']},{rute[i]['Long']}"
                destination = f"{rute[i+1]['Lat']},{rute[i+1]['Long']}"
                url = (
                    f"https://maps.googleapis.com/maps/api/directions/json?"
                    f"origin={origin}&destination={destination}&key={google_api_key}"
                )
                response = requests.get(url)
                data_api = response.json()

                if data_api["status"] == "OK":
                    route_info = data_api["routes"][0]["legs"][0]
                    estimasi_total_jarak_km += route_info["distance"]["value"] / 1000
                    estimasi_total_waktu_menit += route_info["duration"]["value"] / 60

            origin = f"{start_lat},{start_lng}"
            destination = f"{list_tempat[-1]['Lat']},{list_tempat[-1]['Long']}" if len(list_tempat) > 1 else origin
            waypoints = "|".join([f"{p['Lat']},{p['Long']}" for p in list_tempat[:-1]]) if len(list_tempat) > 1 else ""

            maps_rute_url = f"https://www.google.com/maps/dir/?api=1&origin={origin}&destination={destination}"
            if waypoints:
                maps_rute_url += f"&waypoints={waypoints}"

            rekomendasi_text = []
            for i, h in enumerate(list_tempat, 1):
                maps_link = f"https://www.google.com/maps/search/?api=1&query={h['Lat']},{h['Long']}"
                rekomendasi_text.append(
                    f"{i}. [{h['Place_Name']}]({maps_link}) ({h['Category']}) - {h['City']} | Rp{h['Price']} | Rating: {h['Rating']}"
                )

            return {
                "status": "done",
                "message": "Rute dan rekomendasi ditemukan",
                "recommendations": rekomendasi_text,
                "total_jarak_km": round(estimasi_total_jarak_km, 2),
                "total_durasi_menit": round(estimasi_total_waktu_menit, 1),
                "user_session_state": user_session_state,
                "confirmed_state": confirmed_state,
                "maps_rute_url": maps_rute_url
            }
        else:
            return {
                "status": "done",
                "message": "Tidak ditemukan hasil sesuai kriteria.",
                "recommendations": [],
                "user_session_state": user_session_state,
                "confirmed_state": confirmed_state
            }
    else:
        pertanyaan = generate_pertanyaan(confirmed_state)
        return {
            "status": "pending",
            "questions": pertanyaan,
            "user_session_state": user_session_state,
            "confirmed_state": confirmed_state
        }

# Buat interface Gradio
iface = gr.Interface(
    fn=chatbot_interface,
    inputs=[
        gr.Textbox(label="User Input"),
        gr.Number(label="Start Latitude", value=-6.9733),
        gr.Number(label="Start Longitude", value=107.6303),
        gr.Textbox(label="Start Name", value="Start Point"),
        gr.JSON(label="User Session State", value={"CATEGORY": None, "CITY": None, "PRICE": None, "RATING": None}),
        gr.JSON(label="Confirmed State", value={"CATEGORY": False, "CITY": False, "PRICE": False, "RATING": False})
    ],
    outputs="json",
    title="Wisata Recommender Chatbot"
)

iface.launch(share=True)
