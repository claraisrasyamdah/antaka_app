# -*- coding: utf-8 -*-
"""TA_Clara_coba10

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1UuWMjcG4mI5MgGPCpue00hTRhnX4SDeH
"""



"""#LIBRARY"""

from transformers import BertTokenizerFast, BertForTokenClassification
from openai import OpenAI
import requests
import random
import torch
import json
import re

"""#DATA"""

# URL file JSON
url_category = "https://raw.githubusercontent.com/claraisrasyamdah/antaka_2025/refs/heads/main/support_data/category_mapping.json"

try:
    response_category = requests.get(url_category)
    response_category.raise_for_status()  # untuk memunculkan error kalau gagal

    category_mapping = json.loads(response_category.text)

except requests.exceptions.RequestException as e:
    print(f"Terjadi kesalahan saat mengunduh data: {e}")

# URL file JSON
url_city = "https://raw.githubusercontent.com/claraisrasyamdah/antaka_2025/refs/heads/main/support_data/city_mapping.json"

try:
    response_city = requests.get(url_city)
    response_city.raise_for_status()  # untuk memunculkan error kalau gagal

    city_mapping = json.loads(response_city.text)

except requests.exceptions.RequestException as e:
    print(f"Terjadi kesalahan saat mengunduh data: {e}")

# URL file JSON
url_mapping_place = "https://raw.githubusercontent.com/claraisrasyamdah/antaka_2025/refs/heads/main/support_data/mapping_place_alias.json"

try:
    response_mapping_place = requests.get(url_mapping_place)
    response_mapping_place.raise_for_status()  # untuk memunculkan error kalau gagal

    mapping_place_alias = json.loads(response_mapping_place.text)

except requests.exceptions.RequestException as e:
    print(f"Terjadi kesalahan saat mengunduh data: {e}")

# Unduh data dari URL
url = "https://raw.githubusercontent.com/claraisrasyamdah/antaka_2025/refs/heads/main/data/data_wisata.json"
response = requests.get(url)
data_wisata_raw = json.loads(response.text)

# Buat versi yang huruf kecil semua di City dan Category
data_wisata = []
for place in data_wisata_raw:
    place["City"] = place["City"].lower()
    place["Category"] = place["Category"].lower()
    place["Place_Name"] = place["Place_Name"].lower()
    data_wisata.append(place)

data_wisata_raw = json.loads(response.text)

"""#CALLING MODEL

![image.png](data:image/png;base64,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)
"""

# Load model & tokenizer dari Hugging Face Hub
model_name = "claraisra/antaka-v2"
tokenizer = BertTokenizerFast.from_pretrained(model_name)
model = BertForTokenClassification.from_pretrained(model_name)
model.eval()

"""#FUNCTION

##FUNC SUPPORT
"""

def predict_bio(text):
    tokens = tokenizer(text, return_tensors="pt", truncation=True, is_split_into_words=False)
    word_ids = tokens.word_ids(batch_index=0)  # <-- mapping ke kata asli
    with torch.no_grad():
        output = model(**tokens)

    logits = output.logits
    predictions = torch.argmax(logits, dim=2)[0]

    predicted_labels = [model.config.id2label[p.item()] for p in predictions]

    token_words = tokenizer.convert_ids_to_tokens(tokens['input_ids'][0])

    # Gabungkan token dan label berdasar kata asli
    results = []
    previous_word_idx = None
    for token, label, word_idx in zip(token_words, predicted_labels, word_ids):
        if word_idx is None or token in tokenizer.all_special_tokens:
            continue
        if word_idx != previous_word_idx:
            results.append((token, label))  # token baru
        else:
            if label.startswith("I-"):
                results[-1] = (results[-1][0] + token.replace("##", ""), label)
            # else: abaikan label O tambahan
        previous_word_idx = word_idx

    return results

# Fungsi prompting untuk ekstraksi key_highlights, tanggal, dan bahasa
def get_place_name(user_input):
    messages = [
        {
            "role": "system",
            "content": "Anda adalah asisten cerdas yang mengekstraksi nama tempat wisata dari pernyataan pengguna. Kembalikan hanya nama tempat wisata, tanpa penjelasan tambahan."
        },
        {
            "role": "user",
            "content": f"Tolong ekstrak nama tempat dari kalimat ini: \"{user_input}\""
        }
    ]

    response = client.chat.completions.create(
        model=MODEL_NAME,
        messages=messages,
        temperature=0
    )

    content = response.choices[0].message.content.strip()
    return content

def find_specific_place(input_text, mapping_place_alias, data_wisata):
    input_text_lower = input_text.lower()
    place_name_extracted = get_place_name(input_text_lower).lower()

    for canonical_name, alias_list in mapping_place_alias.items():
        for alias in alias_list:
            if alias.lower() == place_name_extracted:

                # Cari tempat yang cocok di data_wisata dengan nama canonical
                matching_places = [
                    place for place in data_wisata
                    if canonical_name.lower() in place["Place_Name"].lower()
                ]

                if matching_places:
                    if len(matching_places) == 1:
                        return matching_places[0]  # Kembalikan seluruh objek
                    else:
                        matching_places_sorted = sorted(matching_places, key=lambda x: x["Rating"], reverse=True)
                        return matching_places_sorted[0]  # Kembalikan yang rating-nya tertinggi

    # Jika tidak ada kecocokan
    return None

# Mapping kata kunci ibadah
KEYWORD_CATEGORY_MAP = {
    "masjid": "Tempat Ibadah",
    "mushola": "Tempat Ibadah",
    "gereja": "Tempat Ibadah",
    "vihara": "Tempat Ibadah",
    "klenteng": "Tempat Ibadah",
    "pura": "Tempat Ibadah",
    "kapel": "Tempat Ibadah",
}

def find_matching_wisata(input_text, entities, mapping_place_alias=mapping_place_alias, data_wisata=data_wisata_raw):
    input_text_lower = input_text.lower()
    matches = []

    # Coba cari tempat spesifik dulu
    specific_place = find_specific_place(input_text, mapping_place_alias, data_wisata)
    if specific_place:
        matches.append(specific_place)
    else:
        # Ambil keyword spesifik tempat ibadah dari input (jika ada)
        keyword_ibadah = None
        if entities["CATEGORY"] == "Tempat Ibadah":
            for keyword in KEYWORD_CATEGORY_MAP:
                if keyword in input_text_lower:
                    keyword_ibadah = keyword
                    break

        for place in data_wisata:
            # Filter berdasarkan kota
            if entities["CITY"] and entities["CITY"].lower() not in place["City"].lower():
                continue
            # Filter berdasarkan kategori
            if entities["CATEGORY"] and entities["CATEGORY"].lower() not in place["Category"].lower():
                continue
            # Filter harga
            if entities["PRICE"] is not None and place["Price"] > entities["PRICE"]:
                continue
            # Filter rating
            if entities["RATING"] is not None and place["Rating"] < entities["RATING"]:
                continue
            # Jika keyword ibadah terdeteksi, pastikan ada di nama tempat
            if keyword_ibadah and keyword_ibadah not in place["Place_Name"].lower():
                continue
            matches.append(place)

    sorted_matches = sorted(matches, key=lambda x: (x["Price"], -x["Rating"]))
    top_matches = random.sample(sorted_matches, k=min(5, len(sorted_matches)))

    return [place["Place_Id"] for place in top_matches]

def extract_entities(token_label_pairs):
    entities = {
        "CATEGORY": None,
        "CITY": None,
        "PRICE": None,
        "RATING": None
    }

    current_entity = None
    for token, label in token_label_pairs:
        if label.startswith("B-"):
            current_entity = label[2:]
            if current_entity in ["CATEGORY", "CITY"]:
                entities[current_entity] = token
            elif current_entity == "PRICE":
                if token.isdigit():
                    entities[current_entity] = int(token)
            elif current_entity == "RATING":
                if token.isdigit():
                    try:
                        entities[current_entity] = float(token)
                    except ValueError:
                        entities[current_entity] = 0.0

        elif label.startswith("I-"):
            entity_type = label[2:]
            if entity_type in ["CATEGORY", "CITY"]:
                if entities[entity_type] is None:
                    # Tangani kasus I-XXX tanpa B-XXX sebelumnya
                    entities[entity_type] = token
                else:
                    entities[entity_type] += " " + token

    return entities

"""##FUNC MAIN"""

# Inisialisasi kredensial API
import os
openai.api_key = os.getenv("OPENAI_API_KEY")
MODEL_NAME = "gpt-3.5-turbo"

# Inisialisasi client OpenAI
client = OpenAI(api_key=openai_api_key)

def normalize_entities(entities):
    def normalize_city(city):
        if not city:
            return None
        city = city.lower().strip()
        return city_mapping.get(city, None)

    def normalize_category(cat):
        if not cat:
            return None
        cat = cat.lower().strip()
        return category_mapping.get(cat, None)

    def normalize_price(price_str):
        if not price_str:
            return None
        price_str = price_str.lower()
        if any(w in price_str for w in ['bebas']):
            return 0
        if any(w in price_str for w in ['murah', 'terjangkau', 'hemat']):
            return 10000
        if any(w in price_str for w in ['sedang', 'standar']):
            return 25000
        if any(w in price_str for w in ['mahal', 'mewah']):
            return 100000

        price_str = price_str.replace("rb", "000").replace("ribu", "000").replace("k", "000")
        digits = re.findall(r'\d+', price_str)

        if digits:
            number = int(''.join(digits))
            if number < 1000:
                number *= 1000
            return number

        return None

    def normalize_rating(rating_str):
        if not rating_str:
            return None
        rating_str = rating_str.lower()
        if rating_str in ['buruk', 'sangat buruk', 'mengecewakan']:
            return 1.0
        if rating_str in ['kurang bagus', 'biasa aja', 'lumayan']:
            return 2.5
        if rating_str in ['cukup bagus', 'oke']:
            return 3.5
        if rating_str in ['bagus', 'recommended', 'bebas']:
            return 4.0
        if rating_str in ['sangat bagus', 'luar biasa', 'mantap']:
            return 4.5
        if rating_str in ['sempurna', 'sangat memuaskan']:
            return 5.0

        try:
            return float(rating_str)
        except:
            return None

    return {
        "CITY": normalize_city(entities.get("CITY")),
        "CATEGORY": normalize_category(entities.get("CATEGORY")),
        "PRICE": normalize_price(str(entities.get("PRICE"))),
        "RATING": normalize_rating(str(entities.get("RATING"))),
    }

"""##INI TRY MULTI-TURN"""

# Simpan state percakapan (ingat entitas user)
user_session_state = {
    "CATEGORY": None,
    "CITY": None,
    "PRICE": None,
    "RATING": None
}

# Update state percakapan
def update_session_state(entities_baru, session_lama):
    for k, v in entities_baru.items():
        if v is not None:
            session_lama[k] = v
    return session_lama

# Fungsi utama percakapan
def tanya_user(user_input):
    global user_session_state
    prediction = predict_bio(user_input)
    prediction.append(user_input)
    batas = len(prediction) - 1
    input_text = prediction[batas]

    entities = normalize_entities(extract_entities(prediction[:batas]))
    print(entities)
    user_session_state = update_session_state(entities, user_session_state)
    hasil = find_matching_wisata(user_input, entities)
    return hasil, user_session_state

tanya_user("Aku mau wisata religi di Yogyakarta")

# Simpan state percakapan
user_session_state = {
    "CATEGORY": None,
    "CITY": None,
    "PRICE": None,
    "RATING": None
}
confirmed_state = {
    "CATEGORY": False,
    "CITY": False,
    "PRICE": False,
    "RATING": False
}

def semua_terkonfirmasi(state):
    return all(state.values())

def generate_pertanyaan(confirmed_state):
    pertanyaan = []
    for entitas in confirmed_state:
        if not confirmed_state[entitas]:
            if entitas == "CATEGORY":
                pertanyaan.append("Jenis wisata yang kamu mau? (Misal: Religi, Alam, Budaya...)")
            elif entitas == "CITY":
                pertanyaan.append("Kota tujuannya di mana? (Misal: Yogyakarta, Bandung...)")
            elif entitas == "PRICE":
                pertanyaan.append("Maksimal harga tiketnya berapa? (Contoh: 50000)")
            elif entitas == "RATING":
                pertanyaan.append("Minimal rating tempatnya? (Contoh: 4.0)")
    return pertanyaan

while True:
    user_input = input("User: ")

    # Prediksi entitas dari input
    prediction = predict_bio(user_input)
    prediction.append(user_input)
    input_text = prediction[-1]
    entities = normalize_entities(extract_entities(prediction[:-1]))

    # Update state
    bebas_keywords = ["tidak tahu", "skip", "ga tau", "gak tau", "bebas", "terserah", "apa aja", "semua", "kategori apapun", "harga berapapun", "gak ada minimal rating", "ga ada batasan"]

    if any(k in user_input.lower() for k in bebas_keywords):
        for key in confirmed_state:
            if not confirmed_state[key]:
                confirmed_state[key] = True
    elif "harga berapapun" in user_input.lower():
        confirmed_state["PRICE"] = True
    else:
        for key in user_session_state:
            if key in entities and entities[key] is not None:
                user_session_state[key] = entities[key]
                confirmed_state[key] = True


    print("\n📌 Filter saat ini:")
    print(f"- Kategori: {user_session_state['CATEGORY']}")
    print(f"- Kota: {user_session_state['CITY']}")
    print(f"- Harga Maks: {user_session_state['PRICE']}")
    print(f"- Min. Rating: {user_session_state['RATING']}")

    if semua_terkonfirmasi(confirmed_state):
        hasil = find_matching_wisata(user_input, user_session_state)
        if hasil:
            print("\n✅ Rekomendasi:")
            for i, h in enumerate([d for d in data_wisata_raw if d["Place_Id"] in hasil], 1):
                print(f"{i}. {h['Place_Name']} ({h['Category']}) - {h['City']} | Rp{h['Price']} | Rating: {h['Rating']}")
        else:
            print("\n⚠️ Tidak ditemukan hasil sesuai kriteria.")
        break  # Selesai
    else:
        pertanyaan = generate_pertanyaan(confirmed_state)
        for p in pertanyaan:
            print("🤖:", p)

"""#API"""

from flask import Flask, request, jsonify

app = Flask(__name__)

# Fungsi generate pertanyaan seperti yang sudah kamu punya
def generate_pertanyaan(confirmed_state):
    pertanyaan = []
    for entitas in confirmed_state:
        if not confirmed_state[entitas]:
            if entitas == "CATEGORY":
                pertanyaan.append("Jenis wisata yang kamu mau? (Misal: Religi, Alam, Budaya...)")
            elif entitas == "CITY":
                pertanyaan.append("Kota tujuannya di mana? (Misal: Yogyakarta, Bandung...)")
            elif entitas == "PRICE":
                pertanyaan.append("Maksimal harga tiketnya berapa? (Contoh: 50000)")
            elif entitas == "RATING":
                pertanyaan.append("Minimal rating tempatnya? (Contoh: 4.0)")
    return pertanyaan

def semua_terkonfirmasi(state):
    return all(state.values())
    
@app.route("/")
def home():
    return render_template("chat.html")  # serve chat.html dari folder templates
    
@app.route("/chatbot", methods=["POST"])
def chatbot():
    data = request.json

    user_input = data.get("user_input", "")
    user_session_state = data.get("user_session_state", {
        "CATEGORY": None,
        "CITY": None,
        "PRICE": None,
        "RATING": None
    })
    confirmed_state = data.get("confirmed_state", {
        "CATEGORY": False,
        "CITY": False,
        "PRICE": False,
        "RATING": False
    })

    # Proses prediksi entitas (dummy, ganti dengan model sebenarnya)
    prediction = predict_bio(user_input)
    prediction.append(user_input)
    input_text = prediction[-1]
    entities = normalize_entities(extract_entities(prediction[:-1]))

    bebas_keywords = ["tidak tahu", "skip", "ga tau", "gak tau", "bebas", "terserah", "apa aja", "semua", "kategori apapun", "harga berapapun", "gak ada minimal rating", "ga ada batasan"]

    if any(k in user_input.lower() for k in bebas_keywords):
        for key in confirmed_state:
            if not confirmed_state[key]:
                confirmed_state[key] = True
    elif "harga berapapun" in user_input.lower():
        confirmed_state["PRICE"] = True
    else:
        for key in user_session_state:
            if key in entities and entities[key] is not None:
                user_session_state[key] = entities[key]
                confirmed_state[key] = True

    if semua_terkonfirmasi(confirmed_state):
        hasil = find_matching_wisata(user_input, user_session_state)
        if hasil:
            rekomendasi = []
            for i, h in enumerate([d for d in data_wisata_raw if d["Place_Id"] in hasil], 1):
                rekomendasi.append(f"{i}. {h['Place_Name']} ({h['Category']}) - {h['City']} | Rp{h['Price']} | Rating: {h['Rating']}")
            return jsonify({
                "status": "done",
                "message": "Rekomendasi ditemukan",
                "recommendations": rekomendasi,
                "user_session_state": user_session_state,
                "confirmed_state": confirmed_state
            })
        else:
            return jsonify({
                "status": "done",
                "message": "Tidak ditemukan hasil sesuai kriteria.",
                "recommendations": [],
                "user_session_state": user_session_state,
                "confirmed_state": confirmed_state
            })
    else:
        pertanyaan = generate_pertanyaan(confirmed_state)
        return jsonify({
            "status": "pending",
            "questions": pertanyaan,
            "user_session_state": user_session_state,
            "confirmed_state": confirmed_state
        })

if __name__ == "__main__":
    app.run(debug=True)
